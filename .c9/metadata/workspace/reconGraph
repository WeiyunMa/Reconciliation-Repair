{"filter":false,"title":"reconGraph","tooltip":"/reconGraph","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":135,"column":0},"action":"insert","lines":["# reconciliationGraph.py","","# Srinidhi Srinivasan, Juliet Forman","# July 2015","","# This file contains function for building the cycle checking graph, ","# reconGrap, which is in the form of a dictionary. This dictionary has keys ","# that are nodes and values that are a list of all the children. The ","# reconGraph represents edges between nodes that show the temporal ","# relationship between the host tree and the parasite Tree. The main function","# in this file is buildReconstruction and the rest of the functions are ","# helper function that are used by buildReconstruction","","def findRoot(Tree):","\t\"\"\"This function takes in a tree and returns a string with the name of ","\tthe root vertex of the tree.\"\"\"","","\tif 'pTop' in Tree:","\t\treturn Tree['pTop'][1]","\treturn Tree['hTop'][1]","","def InitDicts(tree):","\t\"\"\"This function takes as input a tree dictionary and returns a dictionary","\twith all of the bottom nodes of the edges as keys and empty lists as ","\tvalues.\"\"\"","","\ttreeDict = {}","\tfor key in tree:","\t\tif key == 'pTop':","\t\t\ttreeDict[tree[key][1]] = [] ","\t\telif key == 'hTop':","\t\t\ttreeDict[tree[key][1]] = []","\t\telse:","\t\t\ttreeDict[key[1]] = []","\treturn treeDict","","def treeFormat(tree):","\t\"\"\"Takes a tree in the format that it comes out of newickFormatReader and","\tconverts it into a dictionary with keys which are the bottom nodes of the","\tedges and values which are the children.\"\"\"","","\ttreeDict = InitDicts(tree)","\ttreeRoot = findRoot(tree)","\tfor key in tree:","\t\t#deal with case where the key is not in tuple form","\t\tif key == 'hTop' or key == 'pTop':","\t\t\tif tree[key][-2] == None:","\t\t\t\ttreeDict[treeRoot] = treeDict[treeRoot] + [tree[key][-2]]","\t\t\telse:","\t\t\t\ttreeDict[treeRoot] = treeDict[treeRoot] + [tree[key][-2][1]]","\t\t\tif tree[key][-1] == None:","\t\t\t\ttreeDict[treeRoot] = treeDict[treeRoot] + [tree[key][-1]]","\t\t\telse:","\t\t\t\ttreeDict[treeRoot] = treeDict[treeRoot] + [tree[key][-1][1]]","\t\telse:","\t\t\t#where key is in tuple form","\t\t\tif tree[key][-2] == None:","\t\t\t\ttreeDict[key[1]] = treeDict[key[1]] + [tree[key][-2]]","\t\t\telse:","\t\t\t\ttreeDict[key[1]] = treeDict[key[1]] + [tree[key][-2][1]]","\t\t\tif tree[key][-1] == None:","\t\t\t\ttreeDict[key[1]] = treeDict[key[1]] + [tree[key][-1]]","\t\t\telse:","\t\t\t\ttreeDict[key[1]] = treeDict[key[1]] + [tree[key][-1][1]]","\treturn treeDict","","def parentsDict(H, P):","\t\"\"\"Takes a host and a parasite tree with edges as keys and returns a ","\tdictionary with keys which are the bottom nodes of those edges and values","\twhich are the top nodes of those edges.\"\"\"","","\tparentsDict = {}","\tfor key in H:","\t\tif key == 'hTop':","\t\t\tparentsDict[H[key][1]] = H[key][0]","\t\telse:","\t\t\tparentsDict[key[1]] = H[key][0]","\tfor key in P:","\t\tif key == 'pTop':","\t\t\tparentsDict[P[key][1]] = P[key][0]","\t\telse:","\t\t\tparentsDict[key[1]] = P[key][0]","\treturn parentsDict","","def uniquify(list):","\t\"\"\"Takes as input a list and returns a list containing only the unique ","\telements of the input list.\"\"\"","","\tkeys = {}","\tfor e in list:","\t\tkeys[e] = 1","\treturn keys.keys()","","def buildReconstruction(HostTree, ParasiteTree, reconciliation):","\t\"\"\"Takes as input a host tree, a parasite tree, and a reconciliation, and","\treturns a graph where the keys are host or parasite nodes, and the values","\tare a list of the children of a particular node. The graph represents ","\ttemporal relationships between events.\"\"\"","","\tparents = parentsDict(HostTree, ParasiteTree)","\tH = treeFormat(HostTree)","\tP = treeFormat(ParasiteTree)","\treconGraph = H","\treconGraph.update(P) ","\tfor key in reconciliation:","\t\t#deal with transfer case:","\t\tif reconciliation[key][0] == 'T':","\t\t\treconGraph[key[0]] = P[key[0]] + [reconciliation[key][1][1], \\","\t\t\t\t\t\t\t\t\t\t\t\treconciliation[key][2][1]]","\t\t\tparent1 = parents[reconciliation[key][1][1]]","\t\t\tparent2 = parents[reconciliation[key][2][1]]","\t\t\treconGraph[parent1] = reconGraph[parent1] + [key[0]]","\t\t\treconGraph[parent2] = reconGraph[parent2] + [key[0]]","\t\t#deal with speciation case:","\t\telif reconciliation[key][0] == 'S':","\t\t\tparent = parents[key[0]]","\t\t\tif parent != 'Top':","\t\t\t\treconGraph[parent] = reconGraph[parent] + [key[1]]","\t\t\treconGraph[key[1]] = reconGraph[key[1]] + reconGraph[key[0]]","","\t\t#deal with duplication case:","\t\telif reconciliation[key][0] == 'D':","\t\t\tparent = parents[key[1]]","\t\t\tif parent != 'Top':","\t\t\t\treconGraph[parent] = reconGraph[parent] + [key[0]]","\t\t\treconGraph[key[0]] = reconGraph[key[0]] + [key[1]]","\t\t#deal with contemporary case:","\t\telif reconciliation[key][0] == 'C':","\t\t\treconGraph[key[1]] = [None]","\t\t\treconGraph[key[0]] = [None]","\t\t#deak with guilty transfers:","","\tfor key in reconGraph:","\t\treconGraph[key] = uniquify(reconGraph[key])","\treturn reconGraph",""],"id":1}]]},"ace":{"folds":[],"scrolltop":2249,"scrollleft":0,"selection":{"start":{"row":135,"column":0},"end":{"row":135,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":111,"state":"start","mode":"ace/mode/text"}},"timestamp":1437520453210,"hash":"f8ef85f579079f5df094eb73eb16eb20b854cd9b"}